* My rules for c programming

 - all files that are in the same directory are files that are known
   to share a /Domain/. A given Domain can be designated a [[BuildTargets][Build Target]].
 - all files that begin with the same string of characters in the same
   Domain are known as a /Namespace/. All Namespaces have a single
   =.h= file that can be included outside of the Namespace.
   - Optionally, some Namespaces may have =.h= files that contain the
     same prefix as the master header, followed by a dash (-) and some
     other stuff. This is callled a =Subnamespace=. (ie:
     =edbs-jobs.h=)
 - A Domain inside of another Domain (a directory inside of a
   parent directory) is known as a /Child Domain/.
 - At no point should a =.c= file include another =.c= file.
 - Files that end with =_u.h= are known as utility headers, or private
   headers. These files cannot be included in any file outside of the
   namespace.
 - All symbols in non-utility headers must begin with the same prefix
   as the rest of the Subnamespace. (Ie: =edbd_*= =edba_*=)
 - Each namespace may have its own rules as to what other namespaces
   its allowed to include so keep your eyes open.

** Build Targets

A given domain is a build target if it has a makefile, and the
directory must contain one of the following:

 - =main.c= - this is an executable build target.
 - =*_main.c= - In some cases, a Domain may have multiple executables
   that can be generated, in this case each files with the =_main.c=
   suffix can be treated as a seperate entry point for the compiler,
   given that the compiler not include any of the other =_main.c=
   files.
 - =include/= - this is a library build target. Inside this folder are
   header files to be distributed.
 - =*_t.c= - This is a test, not met to be packaged in any way

** makefiles

Every build target directory has a makefile. These makefiles are
designed to run independantly, cd into the directory and run
=make=. The makefile at the top level is designed to run all of them
and perform repository-wide targets.

All files generated by all make files must be done inside a
non-tracked =build= folder. All makefiles can have this overridded by
setting the enviroment variable: ~build=anotherbuildfolder make~

** CMake

CMake is used exclusively for local developing. All packaging,
releasing, and serious testing is always done through make.

** TODO odbm - remove this chapter
The (o)ida(db) (m)onitor. OpenGL graphical interface for monitoring
oidadb files.

 - apt install libgl1-mesa-dev xorg-dev
 - what ever deps are in go.src/go.module


* =make test=

To test OidaDB, you must only need to run =make test=. This will do the following:

 1. It will compile all C code in the OidaDB as if it were building
    the library, however it will not link the object files. These
    object files will be piled into =build/tests=.
 2. It will then glob all files using the =c.src/tests/*_t.c=
    syntax. Each one of these files is expected to be a build
    target. For each one of these files, it will then compile it and
    link it against the object files that were generated in
    step 1. The resulting build for each =*_t.c= file will be built
    into an executable found in =build/tests=, these files are known
    as testexecs.
 3. For each testexec that is built, it will then run that
    testexec. If the testexec does not return a 0 error code, its
    considered a pass. If a testexec returns non-0, or fails to build,
    the test is considered a failure.

All test files in =c.src/tests= that have the scheme
=##-(namespace)_##_t.c= will have a ~main~ defined in them and ready
to build. The first set of numbers is the priority of which it should
be tested (the lower the higher the priority), the default value
is 20. The second set of numbers is arbitary (to seperate test with
same namespace/priority).

Most of these test do NOT require a full library build. They will
pull in the =.h= files on their own in some casees for unit testing.

Each test will have a exit code of 1 if they failed and and all errornous
ouput will be exclusively through stderr. stdout will be used
liberally.

TEST IDEA: Create 2 database files: execute the exact same jobs
between them. Then close the databases' hosts. 0-out the database id
(in their respective header) and check to make sure their sha1s are
equal. The purpose is to prove that the same jobs will always provide
the same changes to the file. And the databases' only difference is
their unique db id.

* Development/Debug builds
Right now all development and debug builds are handled through
CMake. This is because the tool I use to develop and test is the clion
IDE, and clion is retarded with makefiles so I'm forced to use cmake.
* =make release= - Release Builds
Non-debug, release, live, whatever builds are handled through
makefile. Run =make release= to attempt to build, test, and package a
release.
* Links
  - Kanban: https://oidadb.youtrack.cloud/

  TODO: list dependances... see makelist.txt
  also: https://github.com/jtsiomb/libdrawtext



* Dependencies
Here I will list what packages you need to develop this project as
well as what packages you need to deploy this into a release.

Each dependency needs a justification as well as a version that it has
been tested with. Be ready to pop open git blame on these items to
deduce the age of each dependency if it so happens not to work
anymore.

** Release
 - =libopenssl= - cryptographic functions.

** Development
 - =emacs-nox= - for compiling manual =.org= files. emacs 27.1 seems to work.
 - =gcc= - for compiling C. gcc 10.2.1-6 seems to work fine.
 - =m4= - for various macro stuff for generating some summeries. m4 is
   never used in actual code generation. 1.4.18.
 - =make= - for building production-ready builds. 4.3
 - =cmake= - for making development-ready builds. 3.22.1
 - =libopenssl-dev= - headers and libraries for compiling against.
 - =ldd= - glibc. 2.35.
