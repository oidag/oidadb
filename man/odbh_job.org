#+SETUPFILE: ./0orgsetup.org
#+TITLE: odbh_job family

* Synopsis

#+BEGIN_SRC c
#include <oidadb/oidadb.h>

edb_err odbh_jobmode (odbh *handle, odb_jobhint_t hint);
edb_err odbh_job     (odbh *handle, odb_jobdesc jobdesc, odbj **o_jhandle);
edb_err odbh_jobwrite(odbj *jhandle, const void *buf, int bufc);
edb_err odbh_jobread (odbj *jhandle, void *o_buf, int bufc);
#+END_SRC



* Description
The =odbh_job= family of functions are used by the handle install jobs
into the host. For every job that is installed inside the host, a
worker will eventually come by and take ownership of the job and
execute the job to either failure or completion.

Though the exact behaviour of each function will vary depending on the
job mode (set by *=odbh_jobmode=*, which we'll discuss later), though
the fundemetnal purpose of each function stays the same:

 - *=odbh_job=* - Install a job described by [[./odbh_jobdesc_t.org][=jobdesc=]] into the host
   to which =handle= has connected too. Then return a handle for that
   job into the output pointer of =o_jhandle=.
 - *=odbh_jobwrite=* - Set the job (refered to by =jhandle=) to write
   =bufc= bytes of =buf= into the transfer buffer.
 - *=odbh_jobread=* - Set the job (refered to by =jhandle=) to read
   =bufc= bytes of the transfer buffer into =o_buf=.

** Job Modes


* Errors

* See Also

 - [[./odbh.org][OidaDB Handles]]
 - [[./odbh_jobdesc_t.org][=odbh_jobdesc_t=]]

an error that can happen with edbh_job is that the caller has too many
jobs open: "too many" means they have more jobs open concurrently then
there are threads. If we allow more jobs to remain open than threads, this
will cause a deadlock sense all threads (ie: 2) will be doing something,
if we have a 3rd job also open and streaming into, that third jobs buffer
will fill up and then block. The original 2 jobs will then never have
their buffers cleared. Dead locks can also happen due to a full edbp cache.

This only applies to "open buffer" jobs though. If the job has been fully
installed then no deadlock can happen.

Further more, we can have multiple handles (ie: 4) all have an open buffer
job installed and this will not cause a deadlock hmmm

If we have 2 workers, 3 handles h1, h2, h3 . Each handle installs 1 open
buffer job j1, j2, j3... no dead lock.

But what if 1 handle installed 2 jobs j4 thus:

h1 -> j1*
h2 -> j2
h3 -> j3, j4*

* = worker adopted job.

No... no deadlock. Sense each handle is on its own thread, they will all
clear buffers so the worker will always be able to move on.

Make sure handles are installed on different threads!
