#+SETUPFILE: ./0orgsetup.org
#+TITLE: Introduction to liboidadb

* Introduction

OidaDB is software designed to make accessible a massive amount of
structured data to global a network. The magnituded of such data can
grow to millions of terabytes, with every byte accessible within
nanoseconds.

This software is provided to you by means of a software library. The
library will handle the storage, retrieval, caching, multithreading,
hosting, connecting, networking, load balancing, indexing,
communication, memory use, cpu use, disk (SSD/tape/whatever) use, and
error handling. /Your/ software will use this library and gain the
aformentioned accessability without the worry of those things.

If you have previous experiances with other database such as OidaDB's
so called /competition/ such as MySQL, MariaDB, Oracle, SAP, RocksDB,
MongoDB, ect., just go ahead and forget everything you know about
those products. OidaDB is very different from anything else you may
have used. Though your technical knowledge of the underlining system
(linux & general computer technology) will benifit your OidaDB
experiance greatly.

* Installation
The library file, =liboidadb.so= (sometimes with version number before
the =.so=), should be placed in your systems shared library
directory. See your linker's documentation for this. You can mostly
disregard this step because the package management system would have
taken care of this.

 - Debian Systems - /TODO: deb package stuff/
 - Redhat Systems - /TODO: yum package stuff/
 - Non-packaged/other systems - /TODO: tarball package/

If everything is installed properly, the following code can be compiled

#+BEGIN_SRC c
// main.c
int main()
{
    printf("%s\n", odb_version());
}
#+END_SRC

With =gcc main.c -loidadb && a.out=. If you see OidaDB's version,
you're ready to begin.


* Index
 1. [[./preface.org][Preface]]
 2. [[./errors.org][Errors]] - 50% of your job is handling errors; the other 50% is
    making them.
    1. =odb_errstr=
 3. Telemetry - Telemetry options for monitoring internal workings of
    OidaDB.
    1. =odbtelem=
	2. =odbtelem_poll=
 4. Database Creation/Deletion - All the info about creating and
    deleting database files. Then the subsequent opening and closing.
	1. =odb_create=
	2. =odb_createparams_t=
 5. Database Hosts/Handles
    1. =odb_handle=
	2. =odb_host=
	3. =odb_hostpoll=
	4. =odb_hostconfig_t=
 6. [[./elements.org][OidaDB Elements]] - The fundemental building blocks of every database
    1. [[./odb_elm_jobs.org][Jobs]]
	2. [[./odb_elm_objects][Objects]]
	3. [[./odb_elm_structs][Structures]] 
	4. [[./odb_elm_entities][Index & Entities]]
	5. Dynamics
	6. Lookups
 7. [[./odbh.org][The OidaDB Handle]]
    1. [[./odbh_jobdesc_t.org][=odbh_jobdesc_t=]]
    2. [[./odbh_job.org][=odbh_job=]]
	3. [[./odbh_poll.org][=odbh_poll=]]
 8. [[./routines.org][Routines]] - Arbitrary programming for OidaDB

* Appendix
 - Glossery
   - Enums
 - See Also

* Programming Overview
** Interface Model
talk about how errors are returned, typcial call patterns
** Note on Namespaces

 - =edba=: (a)ctionalbe functions
 - =edbd=: file (d)escriptors
 - =edbx=: Host e(x)ecution logic
 - =edbh=: (h)andle wrappers
 - =edbs=: (s)hared memory (intra-node communcation)
 - =edbl=: (l)ocks and concurrency control
 - =edbn=: (n)etwork interfacing
 - =edbp=: file (p)aging
 - =edbw=: (w)orker logic

* OidaDB and Conventional SQL Differences
** Good Applications
Talk about what types of applicaitons can utilize oidadb to its
fullest, and how.
** Bad Applications
Talk about what oidadb shouldn't be used for.
** Naming Symatics
Is this database relational or non-relation? The answer is:
yes. OidaDB doesn't exist on this specturm.
** Queries
** Streams vs Transactions
* Hardware
** Use of OS
OidaDB (as of now) makes heavy use of linux system calls. So don't try
to run this thing on a TI-89 calculator or even worse, don't try to
run it on Windows.

On a more specific note regarding which version of linux OidaDB
depends on is *Linux 3.17 and above* due to its use of the
=memfd_create= system call. This may change in the future. But as of
now that's what I'm writting down.

(note to self: when I eventually make use of =vsocks(7)=, this may up the
minimum version all the way up to 4.8)
** Use of External Code
OidaDB requires the following libraries to operate:

 - pthreads
 - libc (w/ =_GNU_SOURCE= due to use of non-POSIX Open file
   description locks, see =man fcntl=)

** Use of CPUs
** Use of Memory
** Use of Disk
** Use of External Processes (systemd, dbus, ect)
As of now, OidaDB is but a library. It is not an executable. So unless
I plan to incorporate a front-end specification to this manual, OidaDB
is agnostic to the enviroment processes.

* Pages
If you do not know what pages are in computer memory, then you have
some homework to do before really start utilizing OidaDB. In short:
all memory and all data on computer must be stored in blocks of memory
known as pages. The exact size of these pages depends on the computer,
but for nearly all modern computers, that size is 4KiB.

** Page-Load efficiency
To get the truely best speed and efficiency from OidaDB, it comes down
to your utilization of pages. Follow this rule:

 - *Bytes that's accessed at the same time should be on the same
   page.*

OidaDB allows you to follow this rule. OidaDB also allows you to take
advantage of the practical existance of pages. I have always disliked
how databases try to "hide" the importance of pages dispite the amount
of work that is put into moving them around.

If we have a user in a database, that user has some associated
information to them. Maybe even some many-to-many relationships with
other objects in our database. Lets explore this theoretical against
our rule:

 1. If we have a user, we shall also have his name, location,
    password, and email.
 2. How often do we access all of this information at once? Well very
    often, of course. I mean everytime they log in we have to pull
    most of it up just to allow it for them to log in. Thus, It's
    benificial to keep all this information on the same Object (which
    intern will be kept on the same page).
 3. How often do we access only parts of this information? Not very
    often. However, lets say we needed to make a very-active emailing
    script, if we kept all the information in one page, this would
    force our script to load all the user's data despite the fact we
    only need their email.
    - In that case, it may be a good idea to keep a seperate array
      that holds /just/ their emails so the script can work
      efficiently. Such a seperate array can just be updated the
      instant any email is updated in the user table (up-/down-stream
      relationship).

** Encrypted Pages
* System Communication
Here I'll let you in on the architecture of OidaDB and how the various
modules and softwares talk to eachother. I won't talk about exactly
what it is that's communicated, just the medium to how it is
communicated.

** Intra-host
Host processes typcially like to keep all the processing "in
house". That is, likes to use threads instead of processes. These are
known as workers, which we'll cover in detail later. 

So with the use of threads, intra-host communication comes down to
managing multiple threads with intra-process concurrency control.

** Inner-process/Intra-node
Inside of a given node we have a host process and 1-to-many handle
processes. The handle processes connect to the host and communicate
via shared memory. The module that handles this communication known as
=edbs=, which is one of the few bits of code shared between host and
handle.

 - See also: =man shm_overview=

** Inner-node/Intra-database
When you start to use more than 1 node, the exact means of
communication between these nodes starts to become much more
configuratble. This is where you can start to dictate what's best for
your database. You may set up 5 nodes in virtual enviroments on the
same machine, you may set up 5 nodes in the same rack, you may set up
5 nodes in the same country: all of which very in the best possible
way they could communicate.

So with that being said, nodes communicate via highly configruable
linux sockets. So while configuring your nodes, read up on =man
socket= and its various ways to communicate.

** Concurrency Controls
Concurrency control is by far the most complex element of any
high-performance database. The reaction to a mere suggestion of
high-performance concurrency will identify the boys from the men. If I
had limited this database to a single process and a single thread the
entire thing would be done in a few hours.

So believe me that concurrency control is of paramount importance to a
database. And it is with concurrency controls OidaDB obtains its
massive advantages. It takes months of planning, hours and hours of
drawing lines and boxes in dozends of notebooks, and waking up in the
middle of the nights reallizing previously unknown edgecases.

I'm not going to bore you with the details. Just know that when you
use this product your abilities of concurrency control to mine. This
topic is where OidaDB gets most of its value as a product but
ironically its the topic no one cares about.

But there's key terminology you should at least know of:

 - [[https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html][Mutexes]] (See chptr 4.12)
 - [[https://kernel.org/doc/ols/2002/ols2002-pages-479-495.pdf][Futexes]]
 - [[https://man7.org/linux/man-pages/man2/fcntl.2.html][Shared and Exclusive Locks]] (See Advisory record locking)
 - Clutch Locks (an invention of my own)

See Also:

 - [[https://github.com/torvalds/linux/blob/master/Documentation/locking/locktypes.rst][Linux Locking definitions]]

*** Clutch Locks
todo

* The OidaDB File
** Specification
Every single byte that goes from and to OidaDB database will always be
associated to a file. This file, for intents and purposes, /is/ the
database. If you wish to make backups of your database, you'd only
need to copy this database file to a safe destination.
** Lenting
* Configuration
Also note here that configuration is the core database. For network
configuration, see Architectual Configuration
** Page Size
** Memory Settings
** Network Settings
* Architectual Configuration
** Network
** Nodes
Make sure to warn them about overly complex architecutres in leu of
just using a single machine.
** Node Polymorphism
** Host Nodes
** Event Nodes
** Maintance Nodes
** Index Nodes
* Initialization
** Configuring
** Hosting
** Connecting
* Event Stream
The event stream is one of the distinct features of OidaDB. Everytime
something in the database changes, this change is logged in what is
known as the *Event Buffer*. Handles can then optionally listen to the
Event Buffer and poll for the flow of events. This allows Hanldes to
remain updated on what is happening to records they care about.

Speaking in analogies, everytime there's a ~INSERT~ or ~UPDATE~
statement executed, an event is dispatched to everything that is
currently listening to the database so long that they subscribe to
it.

** Application
The purpose of the Event Stream is for real-time obsessed
applications... which, admittedly is a very general term. And
unforuntely I cannot give you examples of rather you need real-time
data or not, it is a design desicion that you are able to have with
OidaDB.

I put it in there so I can applications with live-feed CRUD forms. For
instance, if I'm looking at a user's information on my computer, and
across the world that user decides to update their name on their
phone, I'll see them update their own name right there on my screen.

** Subscriptions
** Event Miss
An important concept you must understand about the Event Stream is its
volitility: the stream will flow, with or without you. The Event
Stream does not wait if all of its subscribers have caught up to
it. If it did wait then it would take but 1 bad handle to grind the
entire database to a hault.

So I submit to you the invention of an "Event Miss": it happens when a
Handle fails to poll from the Event Stream fast enough and thus fails
to observe past events that have sense been overridden from the
buffer. The only way to prevent this from happening is to have faster
handles, with larger buffer pools and faster ways to which they can
filter out events they don't need.

* Errors
** Error Conventions
Talk about error levels.
** Error Definitions
Talk about the error enum
** Critical Errors
* Jobs
everything below this heading should be jobs (structures, entries, ect)

 - make a note on how a single process/thread can install multiple
   jobs but despite the handle running single threaded, the host will
   always execute jobs mutli-threaded.

** Job Lifecycle
** Installing
** Job Buffers
** Failed Jobs
* Structures
** Structure Index
** Structure Anatomy
Make sure to talk about how they're stupid, deliberately.
** Creating Structures
** Updating Structures
Talk about how you can't delete structures, only recreate
** Deleting Structures
* Entries
** Tables
** Entry Index
** Entry Anatomy
*** Minimum Page Straits
** Creating Entries
** Updating Entries
** Deleting Entries
* Objects
** Rows
** Creating Objects
** Updating Objects
** Deleting Objects
** Parallel Executions
** Trash Management
*** Trash Faults
** User Locks
* Dynamics
** Dynamic Configuration
* Lookups
** Native Lookups
** Extended Lookups
* Automatted Maintance
** Defragging
** Excretion
* Notes

 - OidaDB (natively) does NOT contain any permission other the ones
   inheritted from the file. The concept of restricting users to
   certain records is not built in. This is up to you to implement.

* Appendix
** Glossary
(todo: alphabetically sort when done)

 - Pages: [[Pages]]
 - Table: [[Tables]]
 - Objects: [[Objects]]
 - Rows: [[Rows]]

** See Also
Here's some continued reading that influanced OidaDB in one way or
another:

 - https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout
 - https://www.percona.com/blog/2019/11/12/watch-out-for-disk-i-o-performance-issues-when-running-ext4/
 - https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html
 - http://www.dba-oracle.com/t_row_locks_vs_table_locks.htm
 - https://blog.jcole.us/2013/01/03/the-basics-of-innodb-space-file-layout/
 - https://blog.jcole.us/2013/01/07/the-physical-structure-of-innodb-index-pages/
 - https://blog.jcole.us/2013/01/04/page-management-in-innodb-space-files/
 - https://blog.jcole.us/2013/01/10/btree-index-structures-in-innodb/
 - https://docs.oracle.com/cd/E17952_01/mysql-8.0-en/innodb-row-format.html
 - https://www.youtube.com/watch?v=0Dj96yFl1SE
 - https://www.cs.cmu.edu/~christos/courses/721-resources/p297-o_neil.pdf
 - https://mariadb.com/resources/blog/does-innodb-page-size-matter/
 - https://dev.mysql.com/doc/refman/5.7/en/sorted-index-builds.html
 - https://en.wikipedia.org/wiki/R-tree
 - https://www.postgresql.org/files/documentation/pdf/15/postgresql-15-A4.pdf
   - (Part VII)
   - Shoutout to Postgres team
