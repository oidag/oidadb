* DOCUMENTATION:

The most important things bout the edbl.h namespace is the content of
this comment you're reading now. It is imporant you read this comment
and undestand it before you start fucking with the below functions in
anyway.

Firstly, these functions are just wrappers of fcntl(2)... so read up
on that regarding advisory locks. And note that these functions are
just kinda stupid.  The functions don't help you do your work, this
comment does. So enough with the introduction, lets begin.

It is VITAL that you lock the right things in the right order. Not
locking things in the right order WILL result in deadlocks and
headaches.

So, to get the proper order of which to lock things require to know
what job you're trying to do. The first variable to this is the
element type:

 - Entry
 - Structure
 - Objects

Next, what cateogyr of operations are you trying to perform?

 - Create
 - Read
 - Update
 - Delete
 - (defragging will be discussed below)

|          | *Entry*     | *Structure*                  | *Object*             |
| *Create* | entry mutex | structure mutex              | same as update       |
| *Read*   | /no action/ | /no action/                  | clutch off, sh locks |
| *Update* | clutch on   | /not possible/               | clutch off, xl locks |
| *Delete* | clutch on   | clutches on, structure mutex | clutch off, xl locks |


* Note on Page deletion
Sometimes pages are created for an operaiton but that operation ends
up failing for other reasons. In these cases, the operation tries its
best to delete those pages before that operation cleans up lock it
posseses.

Thus, marking pages as deleted in any sort of way must be a completely
independant locking mechanism. Avoid this, look closely and you'll see
a deadlock:

 Op1 (ok): Locks ABC -> creates pages -> operation fails -> Locks Deletion -> Deletes -> unlocks deletion -> unlocks ABC
 Op2 (bad): Locks Deletion -> Locks ABC -> does stuff -> Unlocks ABC -> Unlocks Deletion
* Note on adding object/lookup pages
Nothing shall add/reference any object (or nessacary lookup) pages
without having =ref0c= XL locked. Incrementing ref0c should be the
last step in all processes.

You must lock =ref0c= before you follow =deepright=. This will prevent
two workers from both trying to update deepright in the chance of a
lookup fault.

You must wait to unlock =ref0c= until only after deepright and ref0c
has been fully updated.
* Entry
** XL Clutch Lock
 1. put a XL lock on the first byte (clutch lock)
 2. put a XL lock on the second byte.
 3. remove XL lock from the first byte
 4. Do whatever you need to do with the lock
 5. release the lock from the second byte.
** SH Clutch Lock
 1. put a SH lock on the first byte (clutch lock)
 2. put a SH lock on the second byte.
 3. remove SH lock from the first byte
 4. Do whatever you need to do with the lock
 5. release the lock from the second byte.
** Entry-Creating
  1. Lock the entry-creation mutex
  2. Surf the index for an EDB_TNONE entry.
  3. Place an XL clutch lock on that entry.
  4. Set the type to EDB_TPEND to deter other creation attemps.
  5. Unlock the entry-creation mutex
  6. Whiest retaining the XL clutch lock, make whatever edits are
     needed to the entry and chapter.
  7. Set the type to whatever it needs to be. This is the final
     marker to indicate a non-corrupted entry. if there's a crash
  8. Release the XL clutch lock.
** Entry-Deleting
  1. Place an XL clutch lock on that entry.
  2. Whiest retaining the XL clutch lock, make whatever edits are
     needed to the entry and chapter. DO NOT TOUCH ITS TYPE yet.
  3. Lock the entry-creation mutex
  4. Set the type to EDB_TNONE
  5. Release the XL clutch lock.
  6. Unlock the entry-creation mutex
** Entry-Writting
  1. Place an XL clutch lock on the entry you wish to create.
  2. Whiest retaining the XL clutch lock, make whatever edits are
     needed to the entry and chapter.
  3. Release the XL clutch lock.
** Entry-Reading
  1. Make sure the entry doesn't have a clutch lock
  2. At this point, if you'd like to confidently pull in structure
     information, you can do it here.

* Structure
** Structure-Deleting
You must lock the entry creation mutex so nothing can be created
with the structure you're trying to delete.

You must go through all indexes, placing sh clutch locks on each one,
then make sure it doesn't posses that structure. If it does, then
that's an error, you cannot delete the structure, roll back the locks
and quit.

* Object
** Object-Reading

  1. Read the relevant entry, make sure it exist ([[Entry-Reading]]), keep
     the SH lock on the entry.
  2. With the lookup root page id in hand:
     - SH Lock on the first byte of page
     - Load the page
     - Get the ID of the next page
     - deload page
     - Remove SH lock on first byte
     - Do this recusively until you get the leaf ID
  3. With the leaf ID:
     - Place a SH lock on the object
     - load the page, copy the data
     - Remove SH lock
  4. Finally, remove the SH lock on the entry.

** Object-Updating

  1. For the look up, do the same process as writting as
     [[Object-Reading]] steps 1-2.
     - (todo: Object-Creating) *However*, if a new node of the B-tree must be created, upgrade
       the lock from an SH to an XL lock on the first byte of the node
       that needs to be modified. Then check again to see if it hasn't
       been modified already, thenm modify it if it hasent, then
       remove the lock and continue as normally. This is to remove the
       possiblity of 2 jobs accidentally adding the same new page
       twice.
     - (note to self: upgrading locks is bad, however sense its
       1-lock-per-operation in terms of pages, we arn't dealing with
       multiple recursive locks thus leads to it being impossible to
       dead lock from upgrades)
  2. With the leaf ID:
     - Place an XL lock on the object
     - load the page, edit the data
     - remove the XL lock.
  3. Remove SH lock from entry.

** Object-Creating
*** Static ID Creation (aka Object-Undelete)
 1. Follow the exact same process as [[Object-Deleting]] except instead of
    adding the object from the trash linked list: remove it.
*** Auto ID Creation
  1. Place an SH clutch lock on the entry (thus same as [[Object-Reading]]
     step 1)

  2. Place an XL lock on the entry's trashlast field.
     - This will prevent 2 workers trying to handle 2 seperate
       trashfaults at the same time, which can inadvertantnly remove
       pages out of the trash cycle.

  3. If the trashlast page is 0. Tne this means more pages are needed
     to be created. See [[Object-Creating-Lookup]].

  4. With the trashlast page id, before you load that page, you must
     place a XL lock on the 'trashstart_off' field in the page's
     header.
	 - This will prevent 1 worker from trying tup read trashstart_off
       while another tries to update it at the same time. See
       [[Object-Deletion]].

  5. With the trashlast page loaded, handle all trash faults by:
     - Updating trashlast with the page loaded's trashvor.
     - unloading the page loaded. then releasing trashstart_off lock.
     - repeat step 4-5 until there's no more trash faults or,
       trashlast ends up being 0. In the latter case, go to step 3.

  6. Release the XL lock on the entry's trashlast field.

  4. Place an XL lock on the trash record you wish to modify, then
     update trashstart_off with the next step in the linked list.

  5. Once trashstart_off is updated, release the XL lock on it but
     keep the XL lock on the record.

  6. Do the creating of the record and what not. (If a user flag
     prevents its creation, simply skip this step. Note how what we've
     just done is taken out this record from the trash yet not
     successfully un-trash it. This is actually fine, sense trash
     records must be able to be untrashed that would me this record is
     unfit to be trash. The user would have to manually create this
     with proper flags.)
  7. Release the XL lock from the record.
  8. Release the SH clutch lock on the entry.

*** Object-Creating-Lookup
See [[Note on adding object/lookup pages]]
Note the only time you should be here is from auto-id creation. Thus,
their should be an SH clutch lock on the entry and an XL lock on the
trashlast field. However, trashlast is 0 which means we need more
pages. Let's continue on:


 1. Place an XL lock on the ref0c field. This will prevent any other
    job from creating any new pages what so ever.
    - It should be noted that this mechnism is mostly redundant as we
      have an XL lock on the trashlast field. But locking the
      trashlast field - by definition - doesn't prevent other jobs
      from adding pages, only from other jobs from adding pages to be
      used as blank space. We must lock this for means of having
      consistent offsetids for the object pages.
    - Also it should be noted that, at this time, there is no need to
      place any SH locks on ref0c. ref0c should only ever be updated
      at the very end of this process so any reads of refc will be
      truthful.
 2. Create the (currently unreferenced) object pages
 3. Look at the entry's =lastlookup=, place an XL lock on second byte
    of that page then load it.
    - The reason why we don't put an XL lock on the first byte is
      because lookups should still be able to happen (via
      Object-Reading/Object-Writing). But with this XL lock the only
      thing we seek to block are other attempts to modify the lookup
      pages.
 4.1. If this lookup is full: unlock and unload this lookup. Then:
    a. Create a sibling for the lookup we just unloaded.
       - While creating this sibling, you should set the first
         reference of that sibling. This first reference will either
         be the object pages if this sibling is leaf bearing, or will
         be the child lookup page created in a previous iteration.
    b. follow up to this lookup's parent (be sure to put an XL lock on its parent).
    c. If this parent is also full:
       - If full: go back to step 4.
       - If not full: update and unlock =lastlookup= then go to step 5.
 4.2. If this lookup is not full: refernece the object pages and the
      increment its =refc=.
 5. You can then update and unlock =ref0c=.
 6. Update =trashlast= and go back to the parent instrunctions
  
** Object-Deleting
"Object-Deleting" will be defined as marking the row as deleted,
meaning putting it into trash circulaiton.

 1. Follow the exact same process as [[Object-Updating]] but once the
    object is loaded into memory (and XL locked).
 2. /While the page is loaded/ lock the page's =trashstart_off= field.
    - This will prevent Object-Creation workers as well as other
      Object-Deleting workers from corrupting the cycle.
    - I emphasize "/while the page is loaded/" because its contrary to
      Object-Creation: which must lock =trashstart_off= before the
      page loads. This contradiction (as of now) is strictly for the
      persuit of better engineering. It's always better to install
      locks before loading the page for swifter performace across
      threads. But in this case we already have the page loaded
      because we firstly needed to verify that the record exists at
      all (versus Object-Creation where we know it already exists).
 3. Put the object in the page's trash management linked list (See
    Deleting in the Object trash managmement spec).
 4. Unlock =trashstart_off=.
 5. Optionally, if the page's =trashc= has reached a critical value
    and =trashvor= is null (see discussion in Deleting in object
    trash managmenet) then you can continue on to step 6. otherwise,
    you're good to stop here.
 6. TODO
* Defraging

Notes: PAGE-BASED CLUTCH LOCKS DONT WORK, a dead lock can happen
unless we guarentee that all pages per-entry are in order. Entry based
clutch locks are faster, easier, and defragging is rare so their
interuption-capabilities are worth it.

 1. go through all the pages and put a clutch lock on all relevant
    entries. it is important that you put the clutch locks on in
    accending order of 

hmmmmmm... why don't just put clutch locks in each page header? and
then put a massive lock over the whole range? the header lock will be
the clutch and when there's no more locks being placed the large lock
will be installed... BUT: we must test to make sure that all the
smaller clutch locks will be consolidated into the large lock (note
that all locks are installed via the same discriptor).

 2. Place an xl lock over the entire area and wait
 3. Once the lock is obtained 
